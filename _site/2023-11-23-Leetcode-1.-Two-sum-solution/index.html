<!DOCTYPE html>
<html lang="en">
<!-- Beautiful Jekyll 6.0.1 | Copyright Dean Attali 2023 -->



<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  

  <title>Leetcode 1. Two sum solution | Eric Lin</title>

  
  
  <meta name="author" content="Eric Lin">
  

  <meta name="description" content="In this post, we’ll discover the power of hash tables in solving LeetCode’s Two sum problem. Aim Implements hashtables to solve Two sum. Understand how the hashtables are implemented in Linux. Hash struct introduction source: 2022q1 第 1 週測驗題 The hash table is implemented using a non-circular doubly-linked list structure,...">

  

  

  
  <link rel="alternate" type="application/rss+xml" title="Eric Lin" href="http://localhost:4000/feed.xml">
  

  

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="Eric Lin">
  <meta property="og:title" content="Leetcode 1. Two sum solution | Eric Lin">
  <meta property="og:description" content="In this post, we’ll discover the power of hash tables in solving LeetCode’s Two sum problem. Aim Implements hashtables to solve Two sum. Understand how the hashtables are implemented in Linux. Hash struct introduction source: 2022q1 第 1 週測驗題 The hash table is implemented using a non-circular doubly-linked list structure,...">

  
  <meta property="og:image" content="http://localhost:4000/assets/img/eric.jpeg">
  

  
  <meta property="og:type" content="article">
  
  <meta property="og:article:author" content="Eric Lin">
  
  <meta property="og:article:published_time" content="2023-11-23T00:00:00-05:00">
  <meta property="og:url" content="http://localhost:4000/2023-11-23-Leetcode-1.-Two-sum-solution/">
  <link rel="canonical" href="http://localhost:4000/2023-11-23-Leetcode-1.-Two-sum-solution/">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  <meta property="twitter:title" content="Leetcode 1. Two sum solution | Eric Lin">
  <meta property="twitter:description" content="In this post, we’ll discover the power of hash tables in solving LeetCode’s Two sum problem. Aim Implements hashtables to solve Two sum. Understand how the hashtables are implemented in Linux. Hash struct introduction source: 2022q1 第 1 週測驗題 The hash table is implemented using a non-circular doubly-linked list structure,...">

  
  <meta name="twitter:image" content="http://localhost:4000/assets/img/eric.jpeg">
  

  


  

  
  

  

</head>


<body>
  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="http://localhost:4000/">Eric Lin</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="/">Blog</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/aboutme">About Me</a>
          </li>
        <li class="nav-item">
          <a class="nav-link" id="nav-search-link" href="#" title="Search">
            <span id="nav-search-icon" class="fa fa-search"></span>
            <span id="nav-search-text">Search</span>
          </a>
        </li></ul>
  </div>

  

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="http://localhost:4000/">
          <img alt="Navigation bar avatar" class="avatar-img" src="/assets/img/eric.jpeg" />
        </a>
      </div>
    </div>
  

</nav>



<div id="beautifuljekyll-search-overlay">

  <div id="nav-search-exit" title="Exit search">✕</div>
  <input type="text" id="nav-search-input" placeholder="Search">
  <ul id="search-results-container"></ul>
  
  <script src="https://unpkg.com/simple-jekyll-search@latest/dest/simple-jekyll-search.min.js"></script>
  <script>
    var searchjson = '[ \
       \
        { \
          "title"    : "Raspberry Pi Bluetooth Speaker: A Comprehensive Guide", \
          "desc"     : "Raspberry Pi Bluetooth Speaker: A Comprehensive Guide", \
          "category" : "", \
          "url"      : "/2024-04-01-Raspberry-Pi-Bluetooth-Speaker-A-Comprehensive-Guide/", \
          "date"     : "April  1, 2024" \
        }, \
       \
        { \
          "title"    : "Build Linux Distribution for NXP i.MX 8 with Yocto Project", \
          "desc"     : "Build Linux Distribution for NXP i.MX 8 with Yocto Project", \
          "category" : "", \
          "url"      : "/2024-02-26-Build-Linux-Distribution-for-NXP-iMX-8-with-Yocto-Project/", \
          "date"     : "February 26, 2024" \
        }, \
       \
        { \
          "title"    : "How to Build Linux kernel for BeagleBone Black", \
          "desc"     : "How to Build Linux kernel for BeagleBone Black", \
          "category" : "", \
          "url"      : "/2024-02-06-How-to-Build-Linux-kernel-for-BeagleBone-Black/", \
          "date"     : "February  6, 2024" \
        }, \
       \
        { \
          "title"    : "Leetcode 1. Two sum solution", \
          "desc"     : "Leetcode 1. Two sum solution", \
          "category" : "", \
          "url"      : "/2023-11-23-Leetcode-1.-Two-sum-solution/", \
          "date"     : "November 23, 2023" \
        }, \
       \
       \
        { \
          "title"    : "About me", \
          "desc"     : "About me", \
          "category" : "page", \
          "url"      : "/aboutme/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Hi, I&#39;m Eric", \
          "desc"     : "Hi, I&#39;m Eric", \
          "category" : "page", \
          "url"      : "/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Tag Index", \
          "desc"     : "Tag Index", \
          "category" : "page", \
          "url"      : "/tags/", \
          "date"     : "January 1, 1970" \
        } \
       \
    ]';
    searchjson = JSON.parse(searchjson);

    var sjs = SimpleJekyllSearch({
      searchInput: document.getElementById('nav-search-input'),
      resultsContainer: document.getElementById('search-results-container'),
      json: searchjson
    });
  </script>
</div>





  



<header class="header-section ">
<div class="intro-header ">
  
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Leetcode 1. Two sum solution</h1>
          
          
           
            
            <span class="post-meta">Posted on November 23, 2023</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
  
  
</div>



</header>


<main class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <div class="blog-post">
        <p>In this post, we’ll discover the power of hash tables in solving LeetCode’s <a href="https://leetcode.com/problems/two-sum/">Two sum</a> problem.</p>

<h2 id="aim">Aim</h2>
<ul>
  <li>Implements hashtables to solve <a href="https://leetcode.com/problems/two-sum/">Two sum</a>.</li>
  <li>Understand how the hashtables are implemented in Linux.</li>
</ul>

<h2 id="hash-struct-introduction">Hash struct introduction</h2>
<p><img src="https://hackmd.io/_uploads/rygDMryV6.png" alt="hash_table" /></p>

<blockquote>
  <p>source: <a href="https://hackmd.io/@sysprog/linux2022-quiz1#%E6%B8%AC%E9%A9%97-2">2022q1 第 1 週測驗題</a></p>
</blockquote>

<p>The <code class="language-plaintext highlighter-rouge">hash table</code> is implemented using a non-circular doubly-linked list structure, consisting of (define in  <a href="https://github.com/torvalds/linux/blob/master/include/linux/types.h">include/linux/types.h</a>):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hlist_head</code>: the head of a linked list and represents a bucket.</li>
  <li><code class="language-plaintext highlighter-rouge">hlist_node</code>: a node in the bucket list.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">map_t</code></p>
<ul>
  <li>bits: size of <code class="language-plaintext highlighter-rouge">struct hlist_head</code> array.</li>
  <li>ht: the head of the hash table.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">hash_key</code></p>
<ul>
  <li>the struct stores keys and values and can be linked by <code class="language-plaintext highlighter-rouge">struct hlist_node</code>.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">hlist_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hlist_node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">**</span><span class="n">pprev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> 
    <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">map_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hash_key</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="why-use-pprev-not-pprev-in-hlist_node">Why use <code class="language-plaintext highlighter-rouge">**pprev</code> not <code class="language-plaintext highlighter-rouge">*pprev</code> in <code class="language-plaintext highlighter-rouge">hlist_node</code>?</h3>
<p>The hashtable is implemented through the use of two key structures: <code class="language-plaintext highlighter-rouge">hlist_head</code> and <code class="language-plaintext highlighter-rouge">hlist_node</code>. For purpose of saving memory, it doesn’t include <code class="language-plaintext highlighter-rouge">pprev</code> in the head.</p>

<p>There are two scenarios for <code class="language-plaintext highlighter-rouge">hlist_node</code>:</p>
<ol>
  <li>The previous node is a struct <code class="language-plaintext highlighter-rouge">hlist_head</code>.</li>
  <li>The previous node is a struct <code class="language-plaintext highlighter-rouge">hlist_node</code>.</li>
</ol>

<p><img src="https://i.imgur.com/B5fRMJQ.png" alt="hlist_head" /></p>

<blockquote>
  <p>source: <a href="https://hackmd.io/@meyr543/H1VGHY219">meyr543: 2022q1 Homework1 (quiz1-1)</a></p>
</blockquote>

<h3 id="code-explorations-pprev-vs-pprev">Code Explorations: <code class="language-plaintext highlighter-rouge">*pprev</code> vs. <code class="language-plaintext highlighter-rouge">**pprev</code></h3>
<p>That’s see what will happen with two different structure definitions:</p>
<h4 id="pprev-scenario"><code class="language-plaintext highlighter-rouge">*pprev</code> scenario</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">hlist_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hlist_node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">pprev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n2</span><span class="p">;</span>

<span class="c1">// case 1</span>
<span class="n">n2</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>

<span class="c1">// case 2</span>
<span class="n">n2</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="pprev-scenario-1"><code class="language-plaintext highlighter-rouge">**pprev</code> scenario</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">hlist_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hlist_node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">**</span><span class="n">pprev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n2</span><span class="p">;</span>

<span class="c1">// case 1</span>
<span class="n">n2</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>

<span class="c1">// case 2</span>
<span class="n">n2</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="the-magic-of-pprev">The Magic of <code class="language-plaintext highlighter-rouge">**pprev</code></h4>
<p>What <code class="language-plaintext highlighter-rouge">**pprev</code> accomplishes is direct access to the address of the previous node rather than its value, mitigating the need for intricate type casting. This design choice results in cleaner, more straightforward code.</p>

<p>Beyond simplicity, other advantages emerge, especially during node deletion in hlist. With <code class="language-plaintext highlighter-rouge">**pprev</code> representing the address of the node, the code can seamlessly proceed without the necessity to check whether the value of *pprev is NULL or not.</p>

<h4 id="check-includelinuxlisth">Check <a href="https://github.com/torvalds/linux/blob/master/include/linux/list.h">include/linux/list.h</a></h4>
<p>No list corruption checks in <code class="language-plaintext highlighter-rouge">__hlist_del</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__hlist_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">**</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">;</span>

	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pprev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">,</span> <span class="n">pprev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">__list_del_entry</code>, <code class="language-plaintext highlighter-rouge">line 3</code> is for list corruption checks.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__list_del_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__list_del_entry_valid</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__list_del</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="solve-two-sum-using-hashtable">Solve two sum using hashtable</h2>
<h3 id="map_init">map_init</h3>

<p>Create and initialize an array of fixed size of <code class="language-plaintext highlighter-rouge">struct hlist_head</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAP_HASH_SIZE(bits) (1 &lt;&lt; bits)
</span>
<span class="n">map_t</span> <span class="o">*</span><span class="nf">map_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">map_t</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">map</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
    <span class="n">map</span><span class="o">-&gt;</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAP_HASH_SIZE</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP_HASH_SIZE</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">)[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
        <span class="n">map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="hash-function">hash function</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define GOLDEN_RATIO_32 0x61C88647
</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* High bits are more random, so use them. */</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="n">GOLDEN_RATIO_32</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="find_key">find_key</h3>
<p>Calculate the hash value for the given <code class="language-plaintext highlighter-rouge">key</code>.
Due to the possibility of different key values producing the same hash value, it is necessary to access the hash table at <code class="language-plaintext highlighter-rouge">(map-&gt;ht)[hash value]</code> and check for a matching key.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define container_of(ptr, type, member)               \
    ({                                                \
        void *__mptr = (void *) (ptr);                \
        ((type *) (__mptr - offsetof(type, member))); \
    })
</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hash_key</span> <span class="o">*</span><span class="nf">find_key</span><span class="p">(</span><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">)[</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">hash_key</span> <span class="o">*</span><span class="n">kn</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hash_key</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kn</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kn</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="map_get">map_get</h3>
<p>If a matching key exists, return its bucket. If it doesn’t, return NULL.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">map_get</span><span class="p">(</span><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">hash_key</span> <span class="o">*</span><span class="n">kn</span> <span class="o">=</span> <span class="n">find_key</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">kn</span> <span class="o">?</span> <span class="n">kn</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="map_add">map_add</h3>
<ul>
  <li>Initially, check for the presence of a matching key. If found, return.</li>
  <li>Next, locate the head of the corresponding hash list based on the hash value.</li>
  <li><code class="language-plaintext highlighter-rouge">n-&gt;next = first;</code>: Place the new node <code class="language-plaintext highlighter-rouge">n</code> before the existing <code class="language-plaintext highlighter-rouge">first</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">if (first) first-&gt;pprev = &amp;n-&gt;next;</code>: For cases where the first node exists (<em>indicating at least one node shares the same hash value as the new one</em>), establish a backward link from it to <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">h-&gt;first = n;</code>: Move to the <code class="language-plaintext highlighter-rouge">first</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">n-&gt;pprev = &amp;h-&gt;first;</code>: Establish a backward link from <code class="language-plaintext highlighter-rouge">n</code> to the hash list head.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">map_add</span><span class="p">(</span><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">hash_key</span> <span class="o">*</span><span class="n">kn</span> <span class="o">=</span> <span class="n">find_key</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kn</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">kn</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hash_key</span><span class="p">));</span>
    <span class="n">kn</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">kn</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)];</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kn</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
        <span class="n">first</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="map_deinit">map_deinit</h3>
<p>Remove hash table.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">map_deinit</span><span class="p">(</span><span class="n">map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP_HASH_SIZE</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span> <span class="n">p</span><span class="p">;)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">hash_key</span> <span class="o">*</span><span class="n">kn</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hash_key</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">)</span> <span class="cm">/* unhashed */</span>
                <span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

            <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">**</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
                <span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">pprev</span><span class="p">;</span>
            <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="nl">bail:</span>
            <span class="n">free</span><span class="p">(</span><span class="n">kn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">kn</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="two_sum">two_sum</h3>
<ul>
  <li>Create an hashtable.</li>
  <li>Iterate through the <code class="language-plaintext highlighter-rouge">nums</code> array to search for the value <code class="language-plaintext highlighter-rouge">target - nums[i]</code> in the hash table.</li>
  <li>If the value is not found, insert the <code class="language-plaintext highlighter-rouge">nums[i]</code> into the hash table.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="nf">twoSum</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numsSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">map_t</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_init</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="o">*</span><span class="n">returnSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numsSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">map_get</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* found */</span>
            <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
            <span class="o">*</span><span class="n">returnSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">map_add</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">bail:</span>
    <span class="n">map_deinit</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="hashtables">Hashtables</h2>

<ul>
  <li>Every bucket in the hashtable is a linked list which will hold all objects that are hashed to the same bucket.</li>
  <li>Hashtable contains all elements in different buckets.</li>
  <li>In case a collision does happen, the elements are chained.</li>
  <li>A good hash function should make sure you get O(1) elements into every bucket.</li>
</ul>

<h4 id="hash-collision">Hash collision</h4>
<p>A hash function transforms the search key into an array index. The ideal case is such that no two search keys hashes to the same array index. However, this is not always the case and is impossible to guarantee for unseen given data.</p>

<h4 id="perfect-hash-function">Perfect hash function</h4>
<p>A perfect hash function is defined as an one-to-one function such that each element maps to a unique value in a hastable. It can be created if all the keys are known ahead of time.</p>

<h4 id="hashtables-in-linux">Hashtables in Linux</h4>
<ul>
  <li>The hashtable is an array of <code class="language-plaintext highlighter-rouge">struct hlist_head</code> pointers, where each one points to a different list, and each one of those lists holds all elements that are hashed to the same bucket.</li>
  <li>Every element is essentially part of a hlist and the hashtable only holds the head of these lists.</li>
</ul>

<h2 id="more-hash">More hash</h2>
<ul>
  <li><a href="https://www.cs.hmc.edu/~geoff/classes/hmc.cs070.200101/homework10/hashfuncs.html">Geoff Kuenning：Hash Functions</a></li>
  <li><a href="https://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html#mm">Chiu CC: Hash Table：Intro</a></li>
  <li><a href="https://hackmd.io/@sysprog/linux-hashtable">Linux 核心的 hash table 實作</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Golden_ratio">Wiki: Golden ratio</a></li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Hash_table#:~:text=In%20computing%2C%20a%20hash%20table,that%20maps%20keys%20to%20values.">Wiki: Hash table</a></li>
  <li><a href="https://kernelnewbies.org/FAQ/LinkedLists">How does the kernel implements Linked Lists?</a></li>
  <li><a href="https://kernelnewbies.org/FAQ/Hashtables">How does the kernel implements Hashtables?</a></li>
  <li><a href="https://stackoverflow.com/questions/60870788/how-to-use-the-kernel-hashtable-api#:~:text=That's%20because%20of%20how%20hash,of%20struct%20hlist_node%20%2C%20nothing%20else.">How to use the kernel hashtable API?</a></li>
</ul>

      </div>

      

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=Leetcode+1.+Two+sum+solution&url=http%3A%2F%2Flocalhost%3A4000%2F2023-11-23-Leetcode-1.-Two-sum-solution%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2023-11-23-Leetcode-1.-Two-sum-solution%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F2023-11-23-Leetcode-1.-Two-sum-solution%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

  

</section>



      

      <ul class="pagination blog-pager">
        
        
        <li class="page-item next">
          <a class="page-link" href="/2024-02-06-How-to-Build-Linux-kernel-for-BeagleBone-Black/" data-toggle="tooltip" data-placement="top" title="How to Build Linux kernel for BeagleBone Black">
            <span class="d-none d-sm-inline-block">Next Post</span>
            <i class="fas fa-arrow-right" alt="Next Post"></i>
          </a>
        </li>
        
      </ul>
      
  
  
  

  


  

  



    </div>
  </div>
</main>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      
<ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="mailto:ericlinsechs@gmail.com" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/ericlinsechs" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://linkedin.com/in/eric-lin-a8a187248" title="LinkedIn">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">LinkedIn</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        Eric Lin
        &nbsp;&bull;&nbsp;
      
      2024

      

      

      

      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
